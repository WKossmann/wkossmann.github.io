
:stem:
:toc: left
:toc-title: Sumário
:last-update-label!:
:source-highlighter: pygments

= Respostas Exercícios de PDI
Willian Kossmann <kossmannwillian@outlook.com>
05/08/2017
:appversion: 1.0.0

Site para hospedagem das respostas dos exercicios propostos no 
link:http://agostinhobritojr.github.io/tutoriais/pdi/[tutorial^] do Prof. Dr. Agostinho Brito Jr. 

== Exercicios 2.2 ==

Esta seção é apenas uma introdução a manipulação dos pixels de uma imagem usando diretamente o metodo .at da classe Mat.

=== Exercicio 2.2.1 - Regions ===

* Desenvolvimento:

É solicitado ao usuário dois pontos pertecentes ao interior da imagem, posteriormente é feita a ordenação dos pontos para 
facilitar a varredura da imagem. Logo depois a área definida pelos pontos de interesse é preenchida com a negativa da cor 
anterior, ou seja, subtrair 255 (valor máximo) do valor anterior. Ao fim é mostrado ao usuáro o resultado final.	
	
* Resultados:

Para teste do algoritmo, foi informado inicialmente (20,30) e (130,270) para teste dos limites de entrada e depois inserido 
(130,170). Os resultados foram como esperado.

[[fig_regionsT, Regions]]
//[.text-center]
.Terminal programa Regions
image::ativ2.2/terRegions.png[title="Terminal programa Regions"]

[[fig_regionsR, Regions]]
//[.text-center]
.Saída do programa Regions
image::ativ2.2/resRegions.png[title="Saída do programa Regions"]

* Código: 

[[exa_regions, Regions]]
[source,cpp]
.regions.cpp
----
include::ativ2.2/regions.cpp[]
----

=== Exercicio 2.2.2 - TrocaRegioes ===

* Desenvolvimento:

Para podermos trocar as regioes da imagem, primeiro é nescessário fazer uma cópia da imagem original para depois poder 
altera-la, caso contrário, parte da imagem será perdida. Foi observado neste processo que ao usar o construtor de cópia 
normal da classe Mat do OpenCV, ele não realizava realmente uma cópia das informações apenas passava o ponteiro. 
Neste caso devemos usar o metodo .clone() para efetivamente fazer uma cópia e poder alterá-la sem modificar a matriz original.

A partir disso foi implementado 4 laços pra copiar as informações dos quadrantes diagonais da matriz "entrada" para a matriz 
"saida".  

* Resultados:

Utilizado a imagem biel.png .

[[fig_trocaregioesE, Regions]]
//[.text-center]
.Saída do programa TrocaRegioes
image::ativ2.2/resTrocaRegioes.png[title="Saída do programa TrocaRegioes"]

* Código: 

[[exa_trocaregioes, Regions]]
[source,cpp]
.trocaregioes.cpp
----
include::ativ2.2/trocaregioes.cpp[]
----

== Exercicios 3.2 ==

Esta seção é uma introdução a indentificação de objetos na imagem, juntamente com noções do uso da função floodFill() do 
OpenCV.

=== Exercicio 3.2.1 - Solução ===

* Desenvolvimento:

Para resolver o problema do limite de objetos do programa labeling.cpp apresentado como exemplo, existem várias formas. 
A que eu considerei mais simples e fácil é utilizar os recursos da própria classe Mat, explorando não apenas os 255 valores 
possiveis de cores em tons de cinza, e sim utilizar os possíveis valores das cores RGB. Com isso aumentamos a capacidade 
deintr rotulação de 255 para 16.581.375 (255x255x255). Ou seja cada objeto é rotulado com 3 "IDs" dentro do campo RGB.

* Resultados:

Para a mesma imagem usada no exemplo do tutorial, podemos notar que as bolhas estão no tom de verde, pois é o que inicia na 
contagem. Podemos observar tambem que a contagem de objetos (bolhas) para esta imagem foi de 32.

[[fig_solucaoT, Solucao]]
//[.text-center]
.Terminal do programa Solucao
image::ativ3.2/terSolucao.png[title="Terminal do programa Solucao"]

[[fig_solucaoI, Solucao]]
//[.text-center]
.Saída do programa Solucao
image::ativ3.2/resSolucao.png[title="Saída do programa Solucao"]

* Código: 

[[exa_solucao, Solucao]]
[source,cpp]
.solucao.cpp
----
include::ativ3.2/solucao.cpp[]
----

=== Exercicio 3.2.2 - ContaBuracos ===

* Desenvolvimento:

Para fazer a contagem das bolhas com buraco(s), foi feito primeiro a retirada das bolhas das bordas pois não se pode afirmar
se há ou não buracos nelas. Após isso foi feita a contagem e rotulação das bolhas como feita no exemplo. A partir deste 
resultado iremos dar um preenchimento no fundo da imagem com o tom de cinza diferente dos das bolhas e do antigo fundo 
(proximo tom de cinza depois das rotulações). Com isso os buracos que estão dentro das bolhas permaneceram com o tom de
cinza do fundo antigo (tom de cinza = 0) e assim podemos identifica-los e conta-los. Para isso é percorrida a matriz para
cada bolha encontrada, ou seja, para cada tom de cinza das bolhas encontradas procurando por tom de cinz = 0 no interior 
dessas bolhas (se o pixel anterior ao tom de cinza = 0 encontrado for igual ao tom de cinza da bolha "da vez" uma flag é 
acionada indicando uma bolha com buraco). Pode haver mais buracos dentro da mesma bolha por isso a varredura na matriz 
continua, porém só será contabilizada a bolha com buraco uma única vez. 

* Resultados:
** Passo 1: Retirar bolhas das bordas.
** Passo 2: Contagem e Rotulação das bolhas como no exemplo.
** Passo 3: Preencher o fundo com outro tom de cinza.
** Passo 4: Contar e Rotular o(s) buracos(s) de cada bolha.

Aṕos o procedimento é mostrado no terminal a quantidade de bolhas encontradas. Foi utilizada uma imagem diferente para poder
testar bolhas com mais de um buraco.

[[fig_contaburacos1, ContaBuracos1]]
//[.text-center]
.Passo 1 programa ContaBuracos
image::ativ3.2/resContaBuracos1.png[title="Passo 1 programa ContaBuracos"]

[[fig_contaburacos2, ContaBuracos2]]
//[.text-center]
.Passo 2 programa ContaBuracos
image::ativ3.2/resContaBuracos2.png[title="Passo 2 programa ContaBuracos"]

[[fig_contaburacos3, ContaBuracos3]]
//[.text-center]
.Passo 3 programa ContaBuracos
image::ativ3.2/resContaBuracos3.png[title="Passo 3 programa ContaBuracos"]

[[fig_contaburacos4, ContaBuracos4]]
//[.text-center]
.Passo 4 programa ContaBuracos
image::ativ3.2/resContaBuracos4.png[title="Passo 4 programa ContaBuracos"]

[[fig_contaburacosT, ContaBuracosT]]
//[.text-center]
.Terminal do programa ContaBuracos
image::ativ3.2/terContaBuracos.png[title="Terminal do programa ContaBuracos"]

[[exa_contaburacos, ContaBuracos]]
[source,cpp]
.contaburacos.cpp
----
include::ativ3.2/contaburacos.cpp[]
----

== Exercicio 4.2 - Equalize ==

Neste capítulo tratamos os estudos e atividade envolvendo histogramas.

=== Exercicio 4.2.1 - Equalize ===

* Desenvolvimento:

Utilizada uma função otimizada do opencv de aplicação da formula de equalização.

* Resultados:

[[fig_equalize1, Equalize1]]
//[.text-center]
.Entrada do programa Equalize
image::ativ4.2/resEqualize1.png[title="Entrada do programa Equalize"]

[[fig_equalize2, Equalize2]]
//[.text-center]
.Saida do programa Equalize
image::ativ4.2/resEqualize2.png[title="Saida do programa Equalize"]

[[exa_equalize, Equalize]]
[source,cpp]
.equalize.cpp
----
include::ativ4.2/equalize.cpp[]
----

=== Exercicio 4.2.2 - MotionDetector ===

* Desenvolvimento:

A magnitude da diferença entre os histogramas dos frames de um vídeo pode ser utilizada para verificar 
se houve algum moviemento no vídeo. Nesta atividade foi calculada a soma das diferenças absolutas de 
cada tom de cinza do histograma atual com o histograma anterior. Se esta diferença for maior que um 
certo limite é acionada um alerta na tela, simulando um alarme.

* Resultados:

[[fig_motiondetector, MotionDetector]]
//[.text-center]
.Terminal do programa MotionDetector
image::ativ4.2/terMotionDetector.png[title="Terminal do programa MotionDetector"]

[[exa_motiondetector, MotionDetector]]
[source,cpp]
.motiondetector.cpp
----
include::ativ4.2/motiondetector.cpp[]
----